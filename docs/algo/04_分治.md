# 分治算法 (Divide and Conquer)

分治的核心思想是：**分而治之**。

将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单地直接求解，原问题的解即子问题解的合并。

## 分治三步曲

1.  **分解 (Divide)**: 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。
2.  **解决 (Conquer)**: 若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。
3.  **合并 (Combine)**: 将各个子问题的解合并为原问题的解。

## 经典应用：归并排序 (Merge Sort)

归并排序是典型的分治算法。

1.  **分**: 把数组从中间切成两半。
2.  **治**: 递归地对左右两半进行归并排序。
3.  **合**: 将两个有序的子数组合并成一个有序数组。

```python
def merge_sort(arr):
    # Base Case: 只有一个元素时，天然有序
    if len(arr) <= 1:
        return arr

    # 1. Divide: 从中间切分
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])

    # 2 & 3. Conquer & Combine: 合并两个有序数组
    return merge(left_half, right_half)

def merge(left, right):
    sorted_arr = []
    i = j = 0

    # 谁小取谁
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            sorted_arr.append(left[i])
            i += 1
        else:
            sorted_arr.append(right[j])
            j += 1

    # 处理剩余元素
    sorted_arr.extend(left[i:])
    sorted_arr.extend(right[j:])

    return sorted_arr

# 测试
arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))
# 输出: [3, 9, 10, 27, 38, 43, 82]
```

**时间复杂度**: $O(n \log n)$  
**空间复杂度**: $O(n)$ (需要额外空间辅助合并)

## 经典应用：快速排序 (Quick Sort)

快速排序也是分治思想，但策略与归并不同。

1.  **分**: 选一个**基准值 (Pivot)**，把比它小的放左边，比它大的放右边。
2.  **治**: 递归地对左右两部分进行快速排序。
3.  **合**: 不需要显式合并，因为数据在原数组中已经归位了。

```python
def quick_sort(arr):
    # Base Case
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]  # 选中间值做基准
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # 递归连接
    return quick_sort(left) + middle + quick_sort(right)

print(quick_sort([3, 6, 8, 10, 1, 2, 1]))
```

## 本章小结

-   分治法将 $O(n^2)$ 的问题优化为 $O(n \log n)$ 是极其常见的。
-   **归并排序**：先递归切分，重点在**合并** (Merge)。
-   **快速排序**：重点在**切分** (Partition)，利用基准值直接归位。

---

_下一章：[二分查找](05_二分查找.md)_
