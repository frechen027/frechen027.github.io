# 模拟与枚举

这是最基础、最直观的算法思想。

## 1. 模拟 (Simulation)

模拟就是**题目怎么说，你就怎么做**。不涉及高深的算法技巧，关键在于准确地将自然语言描述的逻辑翻译成代码，并处理好各种边界情况。

### 核心要点

-   仔细阅读题目，不漏掉任何细节。
-   代码逻辑要清晰，变量命名要见名知意。
-   注意特殊情况（如空输入、越界等）。

### 示例：模拟机器人行走

**题目描述**：
机器人初始在 (0, 0)，面向北。指令 "G" 走一步，"L" 左转 90 度，"R" 右转 90 度。给定指令序列，求最终坐标。

```python
def robot_sim(commands: str):
    x, y = 0, 0
    #         北, 东, 南, 西
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    direction = 0  # 0:北, 1:东, 2:南, 3:西

    for cmd in commands:
        if cmd == 'G':
            x += dx[direction]
            y += dy[direction]
        elif cmd == 'L':
            direction = (direction - 1) % 4
        elif cmd == 'R':
            direction = (direction + 1) % 4

    return x, y

print(robot_sim("GGLLGG")) # 结果: (0, 0)
```

## 2. 枚举 (Enumeration / Brute Force)

枚举（也称暴力法）是指列出所有可能的情况，逐一判断是否符合条件。

### 适用场景

-   数据规模较小。
-   没有更好的算法思路时用来保底。
-   用来验证优化算法的正确性（对拍）。

### 核心要点

-   **确定枚举范围**：不重不漏。
-   **优化枚举顺序**：尽早排除非法解（剪枝）。

### 示例：百钱买百鸡

**题目描述**：
公鸡 5 文钱一只，母鸡 3 文钱一只，小鸡 1 文钱三只。用 100 文钱买 100 只鸡，问公鸡、母鸡、小鸡各多少只？

**思路**：

-   公鸡 ($x$) 最多 20 只 ($5 \times 20 = 100$)。
-   母鸡 ($y$) 最多 33 只 ($3 \times 33 = 99$)。
-   小鸡 ($z$) 可以由 $100 - x - y$ 算出，不必循环遍历。

```python
def buy_chicken():
    results = []
    # 优化：只枚举公鸡和母鸡
    for x in range(21):         # 公鸡 0-20
        for y in range(34):     # 母鸡 0-33
            z = 100 - x - y     # 剩下的是小鸡

            # 两个条件：
            # 1. 价格总和为 100
            # 2. 小鸡数量必须是 3 的倍数 (因为由 z/3 计算价格)
            if z % 3 == 0 and (5 * x + 3 * y + z // 3 == 100):
                results.append((x, y, z))
    return results

for res in buy_chicken():
    print(f"公鸡: {res[0]}, 母鸡: {res[1]}, 小鸡: {res[2]}")
```

## 本章小结

-   **模拟**考查代码实现能力，细心是关键。
-   **枚举**考查问题拆解能力，利用数学约束减少循环嵌套是提速的关键。

---

_下一章：[递归](03_递归.md)_
